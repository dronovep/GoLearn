package main

import (
	"fmt"
	"math"
)

// Селекторы - выражения с точкой (кроме квалифицированных имен - имен с учетом пакета)

type Point struct {
	x float64
	y float64
}

//Здесь все равно, с указателем работает метод или нет, тут чтение данных - без ранзницы читать из оригинала или копии
func (o *Point) GetLength() float64 {
	return math.Sqrt(o.x*o.x + o.y*o.y)
}

// Если этот метод сделать работающим на объекте, а не указателе - он перестанет нормально работать
// будет задават координаты объекту-копии, а не целевому
func (o *Point) SetCoordinates(x float64, y float64) {
	o.x = x
	o.y = y
}

// Важно!!! Не имеет значения, используют методы указатель или объект, в вызывающем коде можно использовать селектор
// и на объекте и на указателе - метод все равно вызовется.
// Вот только чтобы операции записи данных в объект сохранялись в объекте - метод должен работать с указателем
// иначе туда передается копия объекта -метод срабатывает, но не на том фактическом объекте, на котором было нужно

//Вывод! Пиши все методы, использующие указатель на объект в качестве ресивера
//В вызывающем коде можно будет сделать селект метода как на указателе, так и на объекте - метод тога все равно
// отработает как с указателем

func main() {

	p := Point{3, 2}
	fmt.Printf("Point: x = %f, y = %f, length = %f\n", p.x, p.y, p.GetLength())
	pp := &p
	fmt.Printf("Point: x = %f, y = %f, length = %f\n", pp.x, pp.y, pp.GetLength())
	p.SetCoordinates(15, 25)
	fmt.Printf("Point: x = %f, y = %f, length = %f\n", p.x, p.y, p.GetLength())
}
